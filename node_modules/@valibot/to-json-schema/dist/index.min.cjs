"use strict";var k=Object.create;var v=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var E=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,M=Object.prototype.hasOwnProperty;var O=(e,r)=>{for(var s in r)v(e,s,{get:r[s],enumerable:!0})},I=(e,r,s,n)=>{if(r&&typeof r=="object"||typeof r=="function")for(let p of E(r))!M.call(e,p)&&p!==s&&v(e,p,{get:()=>r[p],enumerable:!(n=y(r,p))||n.enumerable});return e};var B=(e,r,s)=>(s=e!=null?k(w(e)):{},I(r||!e||!e.__esModule?v(s,"default",{value:e,enumerable:!0}):s,e)),b=e=>I(v({},"__esModule",{value:!0}),e);var _={};O(_,{addGlobalDefs:()=>h,getGlobalDefs:()=>m,toJsonSchema:()=>x,toJsonSchemaDefs:()=>T});module.exports=b(_);var f;function h(e){f={...f??{},...e}}function m(){return f}var g=B(require("valibot"),1);function o(e,r){return e?(e.push(r),e):[r]}function d(e,r){switch(r?.errorMode){case"ignore":break;case"warn":{console.warn(e);break}default:throw new Error(e)}}function l(e,r,s){let n;switch(r.type){case"base64":{e.contentEncoding="base64";break}case"bic":case"cuid2":case"decimal":case"digits":case"emoji":case"hexadecimal":case"hex_color":case"nanoid":case"octal":case"ulid":{e.pattern=r.requirement.source;break}case"description":{e.description=r.description;break}case"email":{e.format="email";break}case"empty":{e.type==="array"?e.maxItems=0:(e.type!=="string"&&(n=o(n,`The "${r.type}" action is not supported on type "${e.type}".`)),e.maxLength=0);break}case"entries":{e.minProperties=r.requirement,e.maxProperties=r.requirement;break}case"integer":{e.type="integer";break}case"ipv4":{e.format="ipv4";break}case"ipv6":{e.format="ipv6";break}case"iso_date":{e.format="date";break}case"iso_date_time":case"iso_timestamp":{e.format="date-time";break}case"iso_time":{e.format="time";break}case"length":{e.type==="array"?(e.minItems=r.requirement,e.maxItems=r.requirement):(e.type!=="string"&&(n=o(n,`The "${r.type}" action is not supported on type "${e.type}".`)),e.minLength=r.requirement,e.maxLength=r.requirement);break}case"max_entries":{e.maxProperties=r.requirement;break}case"max_length":{e.type==="array"?e.maxItems=r.requirement:(e.type!=="string"&&(n=o(n,`The "${r.type}" action is not supported on type "${e.type}".`)),e.maxLength=r.requirement);break}case"max_value":{e.type!=="number"&&(n=o(n,`The "max_value" action is not supported on type "${e.type}".`)),e.maximum=r.requirement;break}case"metadata":{typeof r.metadata.title=="string"&&(e.title=r.metadata.title),typeof r.metadata.description=="string"&&(e.description=r.metadata.description),Array.isArray(r.metadata.examples)&&(e.examples=r.metadata.examples);break}case"min_entries":{e.minProperties=r.requirement;break}case"min_length":{e.type==="array"?e.minItems=r.requirement:(e.type!=="string"&&(n=o(n,`The "${r.type}" action is not supported on type "${e.type}".`)),e.minLength=r.requirement);break}case"min_value":{e.type!=="number"&&(n=o(n,`The "min_value" action is not supported on type "${e.type}".`)),e.minimum=r.requirement;break}case"multiple_of":{e.multipleOf=r.requirement;break}case"non_empty":{e.type==="array"?e.minItems=1:(e.type!=="string"&&(n=o(n,`The "${r.type}" action is not supported on type "${e.type}".`)),e.minLength=1);break}case"regex":{r.requirement.flags&&(n=o(n,"RegExp flags are not supported by JSON Schema.")),e.pattern=r.requirement.source;break}case"title":{e.title=r.title;break}case"url":{e.format="uri";break}case"uuid":{e.format="uuid";break}case"value":{e.const=r.requirement;break}default:n=o(n,`The "${r.type}" action cannot be converted to JSON Schema.`)}if(s?.overrideAction){let p=s.overrideAction({valibotAction:r,jsonSchema:e,errors:n});if(p)return{...p}}if(n)for(let p of n)d(p,s);return e}var C=0;function a(e,r,s,n,p=!1){if(!p){let t=n.referenceMap.get(r);if(t){if(e.$ref=`#/$defs/${t}`,s?.overrideRef){let u=s.overrideRef({...n,referenceId:t,valibotSchema:r,jsonSchema:e});u&&(e.$ref=u)}return e}}if("pipe"in r){for(let t=0;t<r.pipe.length;t++){let u=r.pipe[t];u.kind==="schema"?(t>0&&d('A "pipe" with multiple schemas cannot be converted to JSON Schema.',s),e=a(e,u,s,n,!0)):e=l(e,u,s)}return e}let i;switch(r.type){case"boolean":{e.type="boolean";break}case"null":{e.type="null";break}case"number":{e.type="number";break}case"string":{e.type="string";break}case"array":{e.type="array",e.items=a({},r.item,s,n);break}case"tuple":case"tuple_with_rest":case"loose_tuple":case"strict_tuple":{e.type="array",e.items=[],e.minItems=r.items.length;for(let t of r.items)e.items.push(a({},t,s,n));r.type==="tuple_with_rest"?e.additionalItems=a({},r.rest,s,n):r.type==="strict_tuple"&&(e.additionalItems=!1);break}case"object":case"object_with_rest":case"loose_object":case"strict_object":{e.type="object",e.properties={},e.required=[];for(let t in r.entries){let u=r.entries[t];e.properties[t]=a({},u,s,n),u.type!=="nullish"&&u.type!=="optional"&&e.required.push(t)}r.type==="object_with_rest"?e.additionalProperties=a({},r.rest,s,n):r.type==="strict_object"&&(e.additionalProperties=!1);break}case"record":{"pipe"in r.key&&(i=o(i,'The "record" schema with a schema for the key that contains a "pipe" cannot be converted to JSON Schema.')),r.key.type!=="string"&&(i=o(i,`The "record" schema with the "${r.key.type}" schema for the key cannot be converted to JSON Schema.`)),e.type="object",e.additionalProperties=a({},r.value,s,n);break}case"any":case"unknown":break;case"nullable":case"nullish":{e.anyOf=[a({},r.wrapped,s,n),{type:"null"}],r.default!==void 0&&(e.default=g.getDefault(r));break}case"exact_optional":case"optional":case"undefinedable":{e=a(e,r.wrapped,s,n),r.default!==void 0&&(e.default=g.getDefault(r));break}case"literal":{typeof r.literal!="boolean"&&typeof r.literal!="number"&&typeof r.literal!="string"&&(i=o(i,'The value of the "literal" schema is not JSON compatible.')),e.const=r.literal;break}case"enum":{e.enum=r.options;break}case"picklist":{r.options.some(t=>typeof t!="number"&&typeof t!="string")&&(i=o(i,'An option of the "picklist" schema is not JSON compatible.')),e.enum=r.options;break}case"union":case"variant":{e.anyOf=r.options.map(t=>a({},t,s,n));break}case"intersect":{e.allOf=r.options.map(t=>a({},t,s,n));break}case"lazy":{let t=n.getterMap.get(r.getter);t||(t=r.getter(void 0),n.getterMap.set(r.getter,t));let u=n.referenceMap.get(t);if(u||(u=`${C++}`,n.referenceMap.set(t,u),n.definitions[u]=a({},t,s,n,!0)),e.$ref=`#/$defs/${u}`,s?.overrideRef){let c=s.overrideRef({...n,referenceId:u,valibotSchema:r,jsonSchema:e});c&&(e.$ref=c)}break}default:i=o(i,`The "${r.type}" schema cannot be converted to JSON Schema.`)}if(s?.overrideSchema){let t=s.overrideSchema({...n,referenceId:n.referenceMap.get(r),valibotSchema:r,jsonSchema:e,errors:i});if(t)return{...t}}if(i)for(let t of i)d(t,s);return e}function x(e,r){let s={definitions:{},referenceMap:new Map,getterMap:new Map},n=r?.definitions??m();if(n){for(let i in n)s.referenceMap.set(n[i],i);for(let i in n)s.definitions[i]=a({},n[i],r,s,!0)}let p=a({$schema:"http://json-schema.org/draft-07/schema#"},e,r,s);return s.referenceMap.size&&(p.$defs=s.definitions),p}function T(e,r){let s={definitions:{},referenceMap:new Map,getterMap:new Map};for(let n in e)s.referenceMap.set(e[n],n);for(let n in e)s.definitions[n]=a({},e[n],r,s,!0);return s.definitions}0&&(module.exports={addGlobalDefs,getGlobalDefs,toJsonSchema,toJsonSchemaDefs});
